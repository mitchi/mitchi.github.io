<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Edmond La Chance" />
  <title>The Picky Movie Club Algorithm : A General-Purpose Pattern for Finding Conflicts</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Picky Movie Club Algorithm : A General-Purpose
Pattern for Finding Conflicts</h1>
<p class="author">Edmond La Chance</p>
<p class="date">Oct 5th 2025</p>
</header>
<p>A few years ago, I designed a simple, elegant algorithm to solve a
specific problem in my field. I published it, left research for other
adventures, and thought little of it. But I’ve come to realize that the
solution I built is not a niche tool for one problem, but a powerful,
general-purpose pattern applicable to dozens of domains.</p>
<p>I had accidentally buried a powerful idea in a niche paper. Today, I
want to dig it up and share it properly.</p>
<p>This is the story of that algorithm, how it works, and how a simple
mental model—the Picky Movie Club—unlocks its potential to solve
problems from event scheduling to detecting merge conflicts in code.</p>
<h3 id="the-original-sin-the-n²-problem">The Original Sin: The N²
Problem</h3>
<p>Many computational problems, from the trivial to the profound, boil
down to finding conflicts. Does this meeting clash with another? Do
these two code changes contradict each other? Can this Sudoku cell be a
‘5’?</p>
<p>The naive way to answer these questions is to build a “conflict
graph.” You take every item in your set and compare it to every other
item, drawing a line between them if they conflict. For a set of
<code>N</code> items, this requires roughly <code>N²</code> comparisons.
This brute-force approach works for small numbers, but it quickly
becomes a computational nightmare as <code>N</code> grows.</p>
<p>My original work required building just such a graph for millions of
items. An <code>N²</code> solution worked but… I wanted something
faster.</p>
<h3 id="the-parable-of-the-picky-movie-club">The Parable of the Picky
Movie Club</h3>
<p>Back in the day, I was best friends with Cedric, an AI PhD student
from France who was extremely intelligent and eccentric, and he told me
many times that he did not like to meet new people unless he absolutely
had to.</p>
<p>Imagination and story telling have always been a powerful way for me
to think. And so I began to create a story in my head… of what Cedric
would do if he wanted to avoid people. The Picky Movie Club Parable was
born.</p>
<p>Let me introduce you to Cedric, a movie fan, and the “Database” movie
club he belongs to.</p>
<p>Every year, the Database movie club organizes an event for its
members to socialize and talk about the movies they have watched. For
every film category (horror, action, drama, romance), there are a number
of selected films. Every member is asked to add their ID (a unique
integer) to the list of their favorite film in that category. If a
member does not have a favorite film in the category, the member is
asked to add their ID to the “undecided” list.</p>
<p>So, if Cedric likes the movie <em>The Matrix</em> in the category
“Action” he adds his member ID to <em>The Matrix</em>’s list. Cedric
repeats this process for several categories. He can skip a category if
he has no firm opinion on the best movie.</p>
<p>Cedric is very choosy, and he does not like to spend his time
discussing movie details with people who disagree with his choices. He
wants to avoid awkward conversations. If between him and one other
person there is a disagreement on even a single movie category, Cedric
does not want to converse with them. But he doesn’t mind speaking to
someone who either always agrees with his choices or is undecided.</p>
<p>Last year, at the Database movie club event, Cedric was unprepared,
and had to speak to every other member to find the ones he likes. That
was awful, and he’s not doing that again.</p>
<p>This year, he has a new approach. To avoid starting conversations
with these uninteresting members, Cedric creates a list of the people he
has to avoid. To make this list, Cedric calculates a “avoid list” (or
conflict list) for <em>every category</em> by doing the following:</p>
<ol type="1">
<li>He grabs the list of members who like his favorite movie in that
category.</li>
<li>He grabs the list of members who were undecided in that
category.</li>
<li>He performs the union of these two lists. This gives him a “safe
list” of everyone he <em>doesn’t</em> have a conflict with for that
category.</li>
<li>He then takes the club’s complete membership roster and subtracts
his ‘safe list’. The people who remain are, by definition, the ones who
chose a different movie. This is his ‘avoid list’ for just that one
category.</li>
</ol>
<p>Finally, by merging (taking the union of) the avoid lists from all
the categories he has an opinion on, Cedric creates his final list of
all the members he should avoid at the party. The genius of his plan is
that he never had to ask a single person about their movie choices. He
used the club’s lists as a shortcut, finding all his conflicts without a
single awkward conversation.</p>
<p>Cedric’s final “avoid” list is the complete adjacency list for his
node in the conflict graph.</p>
<h3 id="the-general-algorithm-beyond-the-story">The General Algorithm:
Beyond the Story</h3>
<p>Cedric’s logic is clever, but it’s a specific instance of a more
general pattern. The real algorithm has two “pluggable” pieces: a
<strong>Lookup Rule</strong> and an <strong>Aggregation
Rule</strong>.</p>
<p>Here is the generalized pseudocode:</p>
<pre><code>Algorithm: Generalized Attribute-Conflict Finder

Input:
  - entity: The item we&#39;re finding conflicts for.
  - database: An index mapping (attribute, value) -&gt; {item IDs}.
  - lookup_function: A rule to find potential conflicts for ONE attribute.
  - aggregation_function: A rule to combine potential conflicts into a final list.

Output:
  - finalConflictList: The set of all truly conflicting item IDs.

1. potentialConflictSets = []
2. For each attribute in our entity:
3.    conflicts = lookup_function(attribute, entity.value, database)
4.    conflicts.remove(entity.id) // Don&#39;t conflict with yourself
5.    potentialConflictSets.add(conflicts)
6.
7. finalConflictList = aggregation_function(potentialConflictSets)
8. return finalConflictList</code></pre>
<blockquote>
<h3 id="a-quick-look-at-complexity">A Quick Look at Complexity</h3>
<p>The power of this algorithm comes from its time complexity. Let’s
assume we have <code>N</code> entities, and each has <code>k</code>
attributes.</p>
<ul>
<li><p><strong>The Naive Approach (<code>O(N² * k)</code>):</strong> You
form <code>N * (N-1) / 2</code> pairs of entities (roughly
<code>N²</code>). For each pair, you might have to compare up to
<code>k</code> attributes to see if they conflict.</p></li>
<li><p><strong>The Database Approach:</strong></p></li>
<li><p><strong>Step 1: Building the Database (One-time cost):</strong>
We iterate through all <code>N</code> entities and for each, we make
<code>k</code> insertions into our database. Assuming our database is a
hash map, this setup cost is <code>O(N * k)</code>.</p></li>
<li><p><strong>Step 2: Finding Conflicts:</strong> To build the full
graph, we run our algorithm for all <code>N</code> entities. For each
entity, we loop through its <code>k</code> attributes. Each lookup is a
fast hash map operation, followed by a set operation. The total time is
therefore proportional to <code>N * k</code>.</p></li>
</ul>
<p>The final complexity is dominated by these two steps, both
<code>O(N * k)</code>. This is a monumental improvement over
<code>O(N²)</code>, especially when <code>N</code> is large.</p>
</blockquote>
<p>The magic is that by swapping out the <code>lookup</code> and
<code>aggregation</code> functions, we can solve vastly different
problems. Let’s see it in action.</p>
<hr />
<h2 id="example-1-university-class-scheduling">Example 1: University
Class Scheduling</h2>
<p>Our first stop is a university’s scheduling office. We need to build
a conflict graph for all classes to help find a valid schedule. Each
class needs a time slot and a room, but we can’t have two classes
competing for the same room at the same time.</p>
<h3 id="the-scenario-we-have-eight-classes-to-schedule">The Scenario: We
have eight classes to schedule</h3>
<p><strong>E1:</strong> CS101 Intro to Programming (Time: Mon 9am, Room:
Hall-A)<br />
<strong>E2:</strong> MATH201 Calculus II (Time: Mon 9am, Room:
Hall-B)<br />
<strong>E3:</strong> PHYS150 Mechanics Lab (Time: Mon 9am, Room:
Hall-A)<br />
<strong>E4:</strong> ENG105 Technical Writing (Time: Mon 10am, Room:
Hall-A)<br />
<strong>E5:</strong> CS201 Data Structures (Time: Tue 9am, Room:
Hall-C)<br />
<strong>E6:</strong> HIST110 World History (Time: Mon 10am, Room:
Hall-B)<br />
<strong>E7:</strong> CHEM101 General Chemistry (Time: Mon 9am, Room:
Lab-1)<br />
<strong>E8:</strong> BIO120 Cell Biology (Time: Wed 2pm, Room:
Hall-A)</p>
<h3 id="defining-the-terms">Defining the Terms:</h3>
<p><strong>Entities:</strong> The classes (E1, E2, …, E8).<br />
<strong>Attributes:</strong> Time and Room.<br />
<strong>Conflict Rule:</strong> A true conflict occurs if two classes
want the same Time AND the same Room.</p>
<h3 id="step-1-the-database-the-one-time-setup">Step 1: The Database
(The One-Time Setup)</h3>
<p>We index all eight classes into two lookup tables:</p>
<p><strong>db_Time:</strong></p>
<p>‘Mon 9am’: {1, 2, 3, 7}<br />
‘Mon 10am’: {4, 6}<br />
‘Tue 9am’: {5}<br />
‘Wed 2pm’: {8}</p>
<p><strong>db_Room:</strong> ‘Hall-A’: {1, 3, 4, 8}<br />
‘Hall-B’: {2, 6}<br />
‘Hall-C’: {5}<br />
‘Lab-1’: {7}</p>
<h3 id="step-2-the-rules-plugging-into-the-framework">Step 2: The Rules
(Plugging into the Framework)</h3>
<p><strong>Lookup Rule:</strong> We need to find other classes with the
same attribute value. We’ll call this
<code>find_same_request</code>.<br />
<strong>Aggregation Rule:</strong> A conflict must exist across all
attributes. We must use INTERSECTION.</p>
<h3 id="step-3-the-walkthrough-finding-conflicts-for-e1-cs101">Step 3:
The Walkthrough (Finding conflicts for E1: CS101)</h3>
<p>Our target entity (our Cedric) is E1, which is (Time: Mon 9am, Room:
Hall-A).</p>
<p><strong>Analyze the Time Attribute:</strong></p>
<p>We use <code>find_same_request</code> for Time = ‘Mon 9am’.<br />
The database returns {1, 2, 3, 7}.<br />
We remove E1’s own ID, leaving {2, 3, 7}.<br />
<strong>Potential Conflicts on Time:</strong> {E2, E3, E7}.</p>
<p><strong>Analyze the Room Attribute:</strong></p>
<p>We use <code>find_same_request</code> for Room = ‘Hall-A’.<br />
The database returns {1, 3, 4, 8}.<br />
We remove E1’s own ID, leaving {3, 4, 8}.<br />
<strong>Potential Conflicts on Room:</strong> {E3, E4, E8}.</p>
<p><strong>Aggregate the Results:</strong></p>
<p>We apply the INTERSECTION rule to our potential conflict sets.<br />
Intersection({2, 3, 7}, {3, 4, 8}) gives us {3}.</p>
<p><strong>The Result:</strong> The algorithm correctly identifies that
E3 (PHYS150 Mechanics Lab) is the one and only conflict for E1. Both
classes need Hall-A at Mon 9am. The algorithm did this without ever
comparing E1 to E2, E4, E5, E6, E7, or E8—a significant efficiency
gain.</p>
<h3 id="checking-all-classes">Checking All Classes</h3>
<p>Let’s run the algorithm for all eight classes to build the complete
conflict graph:</p>
<p><strong>E1 (CS101, Mon 9am, Hall-A):</strong> Conflicts with E3<br />
<strong>E2 (MATH201, Mon 9am, Hall-B):</strong> No conflicts ✓<br />
<strong>E3 (PHYS150, Mon 9am, Hall-A):</strong> Conflicts with E1<br />
<strong>E4 (ENG105, Mon 10am, Hall-A):</strong> No conflicts ✓<br />
<strong>E5 (CS201, Tue 9am, Hall-C):</strong> No conflicts ✓<br />
<strong>E6 (HIST110, Mon 10am, Hall-B):</strong> No conflicts ✓<br />
<strong>E7 (CHEM101, Mon 9am, Lab-1):</strong> No conflicts ✓<br />
<strong>E8 (BIO120, Wed 2pm, Hall-A):</strong> No conflicts ✓</p>
<p>The algorithm has identified one scheduling conflict: E1 and E3
cannot both be scheduled. The university needs to either reassign one
class to a different time slot or find a different room for one of
them.</p>
<hr />
<h3 id="example-2-version-control-merge-conflicts">Example 2: Version
Control Merge Conflicts</h3>
<p>Next, let’s tackle a problem familiar to every developer: detecting
merge conflicts.</p>
<p><strong>The Scenario:</strong> A <code>config.yml</code> file is
changed on two different branches, <code>feature-A</code> and
<code>feature-B</code>. We need to check for conflicts when merging
<code>feature-B</code> into <code>feature-A</code>.</p>
<p><strong>Changes on <code>feature-A</code>:</strong><br />
* <strong>A1:</strong> <code>config.yml</code>, Line 1 -&gt;
<code>version: 1.1</code><br />
* <strong>A2:</strong> <code>config.yml</code>, Line 3 -&gt;
<code>beta_feature: true</code></p>
<p><strong>Changes on <code>feature-B</code>:</strong><br />
* <strong>B1:</strong> <code>config.yml</code>, Line 1 -&gt;
<code>version: 2.0-beta</code><br />
* <strong>B2:</strong> <code>config.yml</code>, Line 2 -&gt;
<code>mode: development</code></p>
<p><strong>Defining the Terms:</strong><br />
* <strong>Entities:</strong> Individual line changes (A1, B1,
etc.).<br />
* <strong>Attributes:</strong> The location, a
<code>(file, line_number)</code> pair.<br />
* <strong>Values:</strong> The new content of the line.<br />
* <strong>Conflict Rule:</strong> A conflict occurs if two changes
affect the <strong>SAME</strong> line but have
<strong>DIFFERENT</strong> content.</p>
<p><strong>Step 1: The Database (Index <code>feature-A</code>’s
changes)</strong><br />
<code>db_Changes</code>:<br />
* <code>('config.yml', 1)</code>:
<code>{ content: "version: 1.1", commit: "A1" }</code><br />
* <code>('config.yml', 3)</code>:
<code>{ content: "beta_feature: true", commit:  "A2" }</code></p>
<p><strong>Step 2: The Rules (The Original Picky Movie Club
Logic)</strong><br />
* <strong>Lookup Rule:</strong> For a given line, find changes with
<strong>DIFFERENT</strong> content. We’ll call this
<code>find_different_value</code>.<br />
* <strong>Aggregation Rule:</strong> A conflict on <strong>ANY</strong>
line is enough to cause a merge conflict. We use
<strong>UNION</strong>.</p>
<p><strong>Step 3: The Walkthrough (Checking <code>feature-B</code>’s
changes)</strong></p>
<ul>
<li><strong>Checking B1:
<code>(config.yml, line 1, "version: 2.0-beta")</code></strong>
<ul>
<li>We look up its attribute <code>('config.yml', 1)</code> in the
database.</li>
<li>We find the change from commit A1.</li>
<li>We apply <code>find_different_value</code>: Is
<code>"version: 2.0-beta"</code> different from
<code>"version: 1.1"</code>? Yes.</li>
<li><em>Conflict found: B1 conflicts with A1.</em></li>
</ul></li>
<li><strong>Checking B2:
<code>(config.yml, line 2, "mode: development")</code></strong>
<ul>
<li>We look up its attribute <code>('config.yml', 2)</code> in the
database.</li>
<li>The database has no entry for this key. No changes were made to line
2 on <code>feature-A</code>.</li>
<li><em>No conflict found.</em></li>
</ul></li>
</ul>
<p><strong>The Result:</strong> The algorithm correctly flags the
conflict on line 1 and passes line 2. Because the aggregation rule is
<strong>UNION</strong>, the moment the first conflict is found, the
entire merge can be flagged as a failure.</p>
<hr />
<h3 id="example-3-cloud-computing---vm-anti-affinity">Example 3: Cloud
Computing - VM Anti-Affinity</h3>
<p>Our final example takes us to the cloud. When you click “Launch
Instance” on AWS, Azure, or Google Cloud, your virtual machine needs to
be placed on a physical host within milliseconds. But cloud providers
manage hundreds of thousands of VMs with complex anti-affinity rules:
your VMs should be spread across different hosts for redundancy,
different availability zones for disaster recovery, and separated from
other tenants for security.</p>
<p>Checking every VM against every other VM would create unacceptable
latency. Our approach will be useful here, since it will quickly create
the conflict graph.</p>
<p><strong>The Scenario: Placing VMs in a Data Center</strong></p>
<p>A cloud provider needs to validate a batch of VM placement decisions.
We have six VMs being placed across three physical hosts:</p>
<p><strong>VM Placement Requests:</strong></p>
<p>V1: tenant-A, app-group-X, zone-1 → host-1<br />
V2: tenant-A, app-group-X, zone-1 → host-1<br />
V3: tenant-B, app-group-Y, zone-1 → host-2<br />
V4: tenant-B, app-group-Y, zone-2 → host-2<br />
V5: tenant-C, app-group-X, zone-1 → host-3<br />
V6: tenant-A, app-group-Z, zone-2 → host-3</p>
<p><strong>Anti-Affinity Rules:</strong> To ensure high availability and
fault tolerance: - VMs from the same <strong>tenant</strong> should not
share a physical host (security &amp; blast radius)<br />
- VMs from the same <strong>app-group</strong> should not share a
physical host (redundancy)<br />
- A conflict occurs if ANY of these rules are violated</p>
<p><strong>Defining the Terms:</strong></p>
<p><strong>Entities:</strong> VM placement decisions (VM_ID assigned to
Host_ID).<br />
<strong>Attributes:</strong> The tenant, app-group, and host for each
placement.<br />
<strong>Conflict Rule:</strong> Two placements conflict if they have the
SAME tenant OR same app-group, AND they’re on the SAME host.</p>
<p><strong>Step 1: The Database (The One-Time Setup)</strong></p>
<p>We index all six placements by their tenant and app-group, organized
by which host they’re on:</p>
<p><strong>db_Tenant:</strong></p>
<p>(‘tenant-A’, ‘host-1’): {V1, V2}<br />
(‘tenant-A’, ‘host-3’): {V6}<br />
(‘tenant-B’, ‘host-2’): {V3, V4}<br />
(‘tenant-C’, ‘host-3’): {V5}</p>
<p><strong>db_AppGroup:</strong></p>
<p>(‘app-group-X’, ‘host-1’): {V1, V2}<br />
(‘app-group-X’, ‘host-3’): {V5}<br />
(‘app-group-Y’, ‘host-2’): {V3, V4}<br />
(‘app-group-Z’, ‘host-3’): {V6}</p>
<p><strong>Step 2: The Rules (Plugging into the Framework)</strong></p>
<p><strong>Lookup Rule:</strong> For a given attribute (tenant or
app-group) and host, find all OTHER placements with the same attribute
value on the same host. We use <code>find_same_request</code> from our
scheduling example.<br />
<strong>Aggregation Rule:</strong> A conflict on EITHER tenant OR
app-group is enough to violate anti-affinity. We use UNION.</p>
<p><strong>Step 3: The Walkthrough (Finding conflicts for
V1)</strong></p>
<p>Our target entity is V1: tenant-A, app-group-X on host-1.</p>
<p><strong>Analyze the Tenant Attribute:</strong></p>
<p>We look up (‘tenant-A’, ‘host-1’) in db_Tenant.<br />
The database returns {V1, V2}.<br />
We remove V1’s own ID, leaving {V2}.<br />
Potential Conflicts on Tenant: {V2}.</p>
<p><strong>Analyze the App-Group Attribute:</strong></p>
<p>We look up (‘app-group-X’, ‘host-1’) in db_AppGroup.<br />
The database returns {V1, V2}.<br />
We remove V1’s own ID, leaving {V2}.<br />
Potential Conflicts on App-Group: {V2}.</p>
<p><strong>Aggregate the Results:</strong></p>
<p>We apply the UNION rule to our potential conflict sets.<br />
Union({V2}, {V2}) gives us {V2}.</p>
<p><strong>The Result:</strong><br />
V1 conflicts with V2. Both VMs belong to tenant-A and app-group-X, and
they’re both assigned to host-1. This violates anti-affinity rules—if
host-1 fails, both VMs go down together, and the customer loses
redundancy.</p>
<p><strong>Checking All Placements:</strong></p>
<p>Running the algorithm for all six VMs:</p>
<p><strong>V1:</strong> Conflicts with V2 (same tenant AND app-group on
host-1)<br />
<strong>V2:</strong> Conflicts with V1 (same tenant AND app-group on
host-1)<br />
<strong>V3:</strong> Conflicts with V4 (same tenant AND app-group on
host-2)<br />
<strong>V4:</strong> Conflicts with V3 (same tenant AND app-group on
host-2)<br />
<strong>V5:</strong> No conflicts ✓<br />
<strong>V6:</strong> No conflicts ✓</p>
<p>The placement validator flags four violations. The cloud orchestrator
would need to reassign V2, V4, or others to different hosts before
proceeding.</p>
<h3 id="additional-information-related-work">Additional information,
related work</h3>
<p>This algorithm builds on the well-established concept of inverted
indexes used in information retrieval. What’s novel here is not the data
structure itself, but the general pattern for conflict detection across
domains. To my knowledge, this specific abstraction, with pluggable
lookup and aggregation rules, hasn’t been formalized as a design pattern
for conflict graph construction.</p>
<p>In my original paper, I used this technique specifically for building
a graph for t-way testing (combinatorial testing for interactions). This
blog post generalizes that solution into a broader pattern.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The core pattern is simple:<br />
1. Index your data by its attributes.<br />
2. Define your conflict rules (lookup and aggregation).<br />
3. Run the algorithm to build your conflict graph in near-linear time.
Further improvements include using bitsets for faster set
operations.</p>
<p>The pattern applications we saw in this blog post:</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 31%" />
<col style="width: 34%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr>
<th>Domain</th>
<th>Lookup Rule</th>
<th>Aggregation</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scheduling</td>
<td>find_same</td>
<td>INTERSECTION</td>
<td>Conflict requires same time AND room</td>
</tr>
<tr>
<td>Version Control</td>
<td>find_different</td>
<td>UNION</td>
<td>Any line conflict is enough</td>
</tr>
<tr>
<td>Cloud Computing with VMs</td>
<td>find_same</td>
<td>UNION</td>
<td>Same tenant or app+group + same physical host is a conflict</td>
</tr>
</tbody>
</table>
<p>What started as a niche solution for a software testing problem
turned out to be a flexible framework for a fundamental computational
task: building conflict-graphs. If you are building those, or if you
want to avoid people at your local movie club, perhaps Cedric’s clever
strategies will be useful to you too.</p>
<p><em>You can find the original paper where a specific version of this
algorithm was published <a
href="https://onlinelibrary.wiley.com/doi/10.1002/stvr.1842">here</a>.
The relevant section is “Efficient graph generation.” </em></p>
<h3 id="event-scheduling-python-code">Event Scheduling Python code</h3>
<p>Here is a minimal, runnable Python implementation for our university
scheduling example.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Our Data ---</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;CS101 Intro to Programming&#39;</span>, <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 9am&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-A&#39;</span>},</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;MATH201 Calculus II&#39;</span>,         <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 9am&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-B&#39;</span>},</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;PHYS150 Mechanics Lab&#39;</span>,       <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 9am&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-A&#39;</span>},</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;ENG105 Technical Writing&#39;</span>,    <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 10am&#39;</span>,<span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-A&#39;</span>},</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;CS201 Data Structures&#39;</span>,       <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Tue 9am&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-C&#39;</span>},</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;HIST110 World History&#39;</span>,       <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 10am&#39;</span>,<span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-B&#39;</span>},</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;CHEM101 General Chemistry&#39;</span>,   <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Mon 9am&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Lab-1&#39;</span>},</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dv">8</span>: {<span class="st">&#39;name&#39;</span>: <span class="st">&#39;BIO120 Cell Biology&#39;</span>,         <span class="st">&#39;Time&#39;</span>: <span class="st">&#39;Wed 2pm&#39;</span>, <span class="st">&#39;Room&#39;</span>: <span class="st">&#39;Hall-A&#39;</span>}</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># --- The &quot;Pluggable&quot; Rules for Scheduling ---</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_same_request(attribute, value, database):</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Lookup Rule: Find entities with the SAME attribute value.&quot;&quot;&quot;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> database.get((attribute, value), <span class="bu">set</span>())</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> aggregate_by_intersection(list_of_sets):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Aggregation Rule: A conflict must exist on ALL attributes.&quot;&quot;&quot;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> list_of_sets:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">set</span>()</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">set</span>.intersection(<span class="op">*</span>list_of_sets)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># --- The Generalized Algorithm ---</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_conflicts(class_id, all_classes, database, lookup_fn, aggregate_fn):</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    class_info <span class="op">=</span> all_classes[class_id]</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    potential_conflict_sets <span class="op">=</span> []</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We only care about attributes that define a resource</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    attributes_to_check <span class="op">=</span> [<span class="st">&#39;Time&#39;</span>, <span class="st">&#39;Room&#39;</span>]</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> attr <span class="kw">in</span> attributes_to_check:</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> class_info[attr]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        conflicts <span class="op">=</span> lookup_fn(attr, value, database).copy()</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        conflicts.discard(class_id)  <span class="co"># Remove self</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        potential_conflict_sets.append(conflicts)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> aggregate_fn(potential_conflict_sets)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Main Execution ---</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Build the database (one-time cost)</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> defaultdict(<span class="bu">set</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> class_id, details <span class="kw">in</span> classes.items():</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    db[(<span class="st">&#39;Time&#39;</span>, details[<span class="st">&#39;Time&#39;</span>])].add(class_id)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    db[(<span class="st">&#39;Room&#39;</span>, details[<span class="st">&#39;Room&#39;</span>])].add(class_id)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Find conflicts for all classes</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;University Class Scheduling - Conflict Detection&quot;</span>)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;=&quot;</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>conflict_found <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> class_id <span class="kw">in</span> classes:</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    conflict_ids <span class="op">=</span> find_conflicts(</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        class_id, classes, db, </span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        lookup_fn<span class="op">=</span>find_same_request, </span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        aggregate_fn<span class="op">=</span>aggregate_by_intersection</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="sc">{</span>classes[class_id][<span class="st">&#39;name&#39;</span>]<span class="sc">}</span><span class="ss"> (ID: </span><span class="sc">{</span>class_id<span class="sc">}</span><span class="ss">)&quot;</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Time: </span><span class="sc">{</span>classes[class_id][<span class="st">&#39;Time&#39;</span>]<span class="sc">}</span><span class="ss">, Room: </span><span class="sc">{</span>classes[class_id][<span class="st">&#39;Room&#39;</span>]<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> conflict_ids:</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        conflict_found <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> cid <span class="kw">in</span> conflict_ids:</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;  ⚠ CONFLICTS WITH: </span><span class="sc">{</span>classes[cid][<span class="st">&#39;name&#39;</span>]<span class="sc">}</span><span class="ss"> (ID: </span><span class="sc">{</span>cid<span class="sc">}</span><span class="ss">)&quot;</span>)</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;  ✓ No conflicts&quot;</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="op">+</span> <span class="st">&quot;=&quot;</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> conflict_found:</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Conflicts detected! Schedule adjustments needed.&quot;</span>)</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;No conflicts! Schedule is valid.&quot;</span>)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Expected Output:</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span class="co"># CS101 Intro to Programming (ID: 1)</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a><span class="co">#   Time: Mon 9am, Room: Hall-A</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a><span class="co">#   ⚠ CONFLICTS WITH: PHYS150 Mechanics Lab (ID: 3)</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a><span class="co"># PHYS150 Mechanics Lab (ID: 3)</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="co">#   Time: Mon 9am, Room: Hall-A</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a><span class="co">#   ⚠ CONFLICTS WITH: CS101 Intro to Programming (ID: 1)</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a><span class="co"># (All other classes show: ✓ No conflicts)</span></span></code></pre></div>
</body>
</html>
